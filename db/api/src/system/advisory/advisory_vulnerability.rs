use crate::db::Transactional;
use crate::system::advisory::affected_package_version_range::AffectedPackageVersionRangeContext;
use crate::system::advisory::fixed_package_version::FixedPackageVersionContext;
use crate::system::advisory::not_affected_package_version::NotAffectedPackageVersionContext;
use crate::system::advisory::AdvisoryContext;
use crate::system::error::Error;
use huevos_common::purl::Purl;
use huevos_entity as entity;
use sea_orm::{ActiveModelTrait, ColumnTrait, EntityTrait, QueryFilter, Set};

#[derive(Clone, Debug)]
pub struct AdvisoryVulnerabilityContext {
    pub advisory: AdvisoryContext,
    pub vulnerability: entity::advisory_vulnerability::Model,
}

impl From<(&AdvisoryContext, entity::advisory_vulnerability::Model)>
    for AdvisoryVulnerabilityContext
{
    fn from(
        (advisory, vulnerability): (&AdvisoryContext, entity::advisory_vulnerability::Model),
    ) -> Self {
        Self {
            advisory: advisory.clone(),
            vulnerability,
        }
    }
}

impl AdvisoryVulnerabilityContext {
    pub async fn get_fixed_package_version<P: Into<Purl>>(
        &self,
        pkg: P,
        tx: Transactional<'_>,
    ) -> Result<Option<FixedPackageVersionContext>, Error> {
        let purl = pkg.into();

        if let Some(package_version) = self.advisory.system.get_package_version(purl, tx).await? {
            Ok(entity::fixed_package_version::Entity::find()
                .filter(
                    entity::fixed_package_version::Column::AdvisoryId.eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::fixed_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.system.connection(tx))
                .await?
                .map(|affected| (self, affected).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn get_not_affected_package_version<P: Into<Purl>>(
        &self,
        pkg: P,
        tx: Transactional<'_>,
    ) -> Result<Option<NotAffectedPackageVersionContext>, Error> {
        let purl = pkg.into();

        if let Some(package_version) = self.advisory.system.get_package_version(purl, tx).await? {
            Ok(entity::not_affected_package_version::Entity::find()
                .filter(
                    entity::not_affected_package_version::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::not_affected_package_version::Column::PackageVersionId
                        .eq(package_version.package_version.id),
                )
                .one(&self.advisory.system.connection(tx))
                .await?
                .map(|not_affected_package_version| (self, not_affected_package_version).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn get_affected_package_range<P: Into<Purl>>(
        &self,
        pkg: P,
        start: &str,
        end: &str,
        tx: Transactional<'_>,
    ) -> Result<Option<AffectedPackageVersionRangeContext>, Error> {
        let purl = pkg.into();

        if let Some(package_version_range) = self
            .advisory
            .system
            .get_package_version_range(purl.clone(), start, end, tx)
            .await?
        {
            Ok(entity::affected_package_version_range::Entity::find()
                .filter(
                    entity::affected_package_version_range::Column::AdvisoryId
                        .eq(self.advisory.advisory.id),
                )
                .filter(
                    entity::affected_package_version_range::Column::PackageVersionRangeId
                        .eq(package_version_range.package_version_range.id),
                )
                .one(&self.advisory.system.connection(tx))
                .await?
                .map(|affected| (self, affected).into()))
        } else {
            Ok(None)
        }
    }

    pub async fn ingest_not_affected_package_version<P: Into<Purl>>(
        &self,
        pkg: P,
        tx: Transactional<'_>,
    ) -> Result<NotAffectedPackageVersionContext, Error> {
        let purl = pkg.into();
        if let Some(found) = self
            .get_not_affected_package_version(purl.clone(), tx)
            .await?
        {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .system
            .ingest_package_version(purl, tx)
            .await?;

        let entity = entity::not_affected_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.system.connection(tx)).await?,
        )
            .into())
    }

    pub async fn ingest_fixed_package_version<P: Into<Purl>>(
        &self,
        pkg: P,
        tx: Transactional<'_>,
    ) -> Result<FixedPackageVersionContext, Error> {
        let purl = pkg.into();
        if let Some(found) = self.get_fixed_package_version(purl.clone(), tx).await? {
            return Ok(found);
        }

        let package_version = self
            .advisory
            .system
            .ingest_package_version(purl, tx)
            .await?;

        let entity = entity::fixed_package_version::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_id: Set(package_version.package_version.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.system.connection(tx)).await?,
        )
            .into())
    }

    pub async fn ingest_affected_package_range<P: Into<Purl>>(
        &self,
        pkg: P,
        start: &str,
        end: &str,
        tx: Transactional<'_>,
    ) -> Result<AffectedPackageVersionRangeContext, Error> {
        let purl = pkg.into();
        if let Some(found) = self
            .get_affected_package_range(purl.clone(), start, end, tx)
            .await?
        {
            return Ok(found);
        }

        let package_version_range = self
            .advisory
            .system
            .ingest_package_version_range(purl, start, end, tx)
            .await?;

        let entity = entity::affected_package_version_range::ActiveModel {
            id: Default::default(),
            advisory_id: Set(self.advisory.advisory.id),
            package_version_range_id: Set(package_version_range.package_version_range.id),
        };

        Ok((
            self,
            entity.insert(&self.advisory.system.connection(tx)).await?,
        )
            .into())
    }
}
